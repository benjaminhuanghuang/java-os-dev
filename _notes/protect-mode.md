## Reference
- https://www.wikiwand.com/en/Global_Descriptor_Table

C编译器通常只能生成32位模式的机器语言。如果一定要生成16位模式机器语言，虽然也不是做不到，但是很费事，还没什么好处。

CPU有16位和32位两种模式。如果以16位模式启动的话，用AX和CX等16位寄存器会非常方便，但反过来，像EAX和ECX等32位的寄存器，使用起来就很麻烦。另外，16位模式和32位模式中，机器语言的命令代码不一样。同样的机器语言，解释的方法也不一样，所以16位模式的机器语言在32位模式下不能运行，反之亦然。

32位模式下可以使用的内存容量远远大于1MB。另外，CPU的自我保护功能（识别出可疑的机器语言并进行屏蔽，以免破坏系统）在16位下不能用，但32位下能用

在实模式下，cpu只能处理最多16位的数据，地址总线有20位，使用16位寄存器，16位数据总线，20位的地址总线，寻址方式是由段和偏移两部分
```
  物理地址 = 段值 * 16 + 偏移
```
段值和偏移都只能用16位来表示，段值16位，16是等于2^4，所以段值*16也就相当于一个20位的数字，由此段值*16的数值不会超过1M,
而偏移16位，能表示的地址范围也就不超过4K,因此整个物理地址能抵达的范围也就是1M + 4k.

在保护模式下，cpu可以处理32位的数据，同时地址总线也扩张到32位，这样，cpu能访问的内存有4G.

在原来的实模式下，cs, ds这些16位的寄存器往往用来存储段值，在保护模式下，这些寄存器用来存储指向GDT某个描述符的索引。在保护模式下，访问某处的内存时，仍然使用寄存器:偏移 的方式，但是CPU的对地址的计算方法不再使用上面的公式，而是把寄存器中的值当做访问GDT的索引，在GDT中找到对应的描述符，从描述符中获得要访问内存的基地址，然后将基地址加上偏移，进而得到要访问的具体地址。由此，就突破了上面寻址公式的1M范围限制。如果我们在GDT中设置一个描述符，这个描述符所描述的基地址设置为5M,那么当我们用寄存器指向这个描述符时，系统就能够读取5M以上的内存了

## Descriptor
![](./gdt.png)
8个字节

Segment Limit / Length(20位， 1M)， BYTE0, BYTE1, BYTE6 低4位

Base Address(32位，) BYTE1, BYTE2, BYTE3, BYTE7

属性 BTYE5


```
/*
  BYTE 7 | BYTE 6 | BYTE 5 | BYTE 4 | 
  BYTE 3 | BYTE 2 | BYTE 7 | BYTE 0 |
*/
public class GDT
{
    byte[] segmentLengthLow = new byte[2];  // BYTE1 BYTE0

    byte[] baseAddressLow = new byte[3];  // BYTE4 BYTE3 BYTE2

    byte[] attribute = new byte[2];      // BYTE5 BYTE6, BYTE6的低位4bit用于segment length

    byte addressHigh;        // BYTE 7

}

```

## ASM 指令

